<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黄的记录`Blog</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-26T08:58:38.829Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小黄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>负载均衡 | 常见算法初探</title>
    <link href="http://example.com/posts/e1d15606.html"/>
    <id>http://example.com/posts/e1d15606.html</id>
    <published>2024-01-26T08:57:13.098Z</published>
    <updated>2024-01-26T08:58:38.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-负载均衡算法分类"><a href="#1-负载均衡算法分类" class="headerlink" title="1. 负载均衡算法分类"></a>1. 负载均衡算法分类</h1><p>抛开技术细节、根据算法的期望可以大致分为以下几类</p><table><thead><tr><th align="left">类别</th><th align="left">期望描述</th></tr></thead><tbody><tr><td align="left">任务平分类</td><td align="left">将接受到的请求平均分发到服务器，”平均”不是特指绝对数值的平均，也可以是权重平均、动态权重平均</td></tr><tr><td align="left">Hash类</td><td align="left">根据请求的某些关键信息进行hash运算，将相同hash值的请求负载到同一RS。常见有源ip hash，uid hash</td></tr><tr><td align="left">响应优先类</td><td align="left">根据RS的响应时间调整请求分配</td></tr><tr><td align="left">系统负载优先类</td><td align="left">根据RS的CPU负载、IO使用率、网卡吞吐量等系统性能指标调整请求分配</td></tr></tbody></table><h1 id="2-常见负载均衡算法"><a href="#2-常见负载均衡算法" class="headerlink" title="2. 常见负载均衡算法"></a>2. 常见负载均衡算法</h1><h2 id="2-1-轮询"><a href="#2-1-轮询" class="headerlink" title="2.1 轮询"></a>2.1 轮询</h2><p>接收到的请求按照顺序轮流分配请求到服务器。轮询是一种最简单的负载均衡策略，不关心服务器实际性能与负载。   简单即是轮询的优点也是缺点</p><ul><li><p>优点</p><ul><li>简单，只依赖服务器与负载均衡系统的连接     感知服务器状态</li></ul></li><li><p>缺点</p><ul><li><p><strong>当服务器系统负载很高，或当服务器出现严重故障(bug)从而无法正常处理请求，但未跟负载均衡系统断开连接时，轮询策略依旧会将请求分配到异常的服务器</strong></p></li><li><p>不能根据服务器配置高低来分配请求</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">nextServerCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询得到下一服务器下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modulo 可用服务器数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCounter.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCounter.compareAndSet(current, next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-随机"><a href="#2-2-随机" class="headerlink" title="2.2 随机"></a>2.2 随机</h2><p>​    接收到的请求根据随机数分配请求到服务器。优缺点跟轮询类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">chooseRandomInt</span><span class="params">(<span class="type">int</span> serverCount)</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(serverCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-加权轮询"><a href="#2-3-加权轮询" class="headerlink" title="2.3 加权轮询"></a>2.3 加权轮询</h2><p>针对轮询策略无法根据服务器处理能力高低分配请求的缺点，可以使用配置权重的方式来实现。</p><h2 id="2-4-动态加权轮询算法"><a href="#2-4-动态加权轮询算法" class="headerlink" title="2.4 动态加权轮询算法"></a>2.4 动态加权轮询算法</h2><p>通过分析固定周期内某台服务器请求的错误次数、成功次数来动态加减服务器权重。</p><h2 id="2-5-一致性Hash算法"><a href="#2-5-一致性Hash算法" class="headerlink" title="2.5 一致性Hash算法"></a>2.5 一致性Hash算法</h2><p>   根据请求的某些特定信息进行hash运算，将相同hash值分配到同一服务器。</p><ul><li>根据 uid&#x2F;session id hash，相同的用户会话会负载到相同的服务器</li><li>根据 client ip hash，相同的源设备负载到相同的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">choose</span><span class="params">(Object key, <span class="type">int</span> serverCount)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">selectedIndex</span> <span class="operator">=</span> Hashing.consistentHash(hashcode, serverCount); <span class="comment">// 使用Guava的一致性哈希算法</span></span><br><span class="line">    <span class="keyword">return</span> selectedIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-响应优先算法"><a href="#2-6-响应优先算法" class="headerlink" title="2.6 响应优先算法"></a>2.6 响应优先算法</h2><ul><li><p>响应优先算法是从客户端角度来选择服务器的算法，优先分配响应速度最快的服务器，通过这种方式让客户端能最快响应。</p></li><li><p>实现响应优先算法需要感知服务器状态，收集、维护响应时间这个维度信息。</p></li><li><p>复杂点：</p><ul><li><p>负载均衡系统需要收集、维护、分析每个服务器每次请求的响应时间。</p></li><li><p>为了减少收集、分析所有请求响应时间的性能消耗，可以使用采样方式来收集，但采样方式会减少准确率，同时也会带来实现复杂度。</p></li><li><p>还需要考虑会不会因为响应优先 而导致瞬间大量的请求同时请求到极少部分服务器，能否平滑的接受请求和转移</p></li></ul></li></ul><h2 id="2-7-系统负载优先算法"><a href="#2-7-系统负载优先算法" class="headerlink" title="2.7 系统负载优先算法"></a>2.7 系统负载优先算法</h2><ul><li><p>同响应优先算法一样，本质上系统负载优先算法也是通过感知服务器状态，将请求分配到负载最低的服务器。</p></li><li><p>不同的是系统负载优先是站在服务器角度来选择分配权重，且关心的是服务器CPU负载、I&#x2F;O使用率、网卡吞吐量、网络连接数等维度的状态。</p></li><li><p>不同的负载均衡系统会根据应用场景选择最关注的服务器状态。如CPU密集型系统关注CPU负载，I&#x2F;O密集型系统关注I&#x2F;O使用率，LVS关注连接数。</p></li><li><p>同响应优先算法一样，由于需要感知服务器状态，进行周期统计。需要对服务器和负载均衡系统都进行一定的开发才能实现，带来了较高的复杂度，容易出现隐蔽的bug或者由于设计不好而成为性能瓶颈。</p></li></ul><h2 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8 总结"></a>2.8 总结</h2><p>一般的负载均衡算法无法处理服务器应用异常而未与负载均衡系统断开的场景。</p><p>响应优先算法和系统负载优先算法理论上可以解决上述问题。</p><p><strong>使用其余负载均衡算法的负载均衡系统可以引入类似的熔断降级等机制来对服务质量出现问题的服务器进行异常处理。</strong></p><p>下文预告： Nacos、Feign等常用组件使用的负载均衡算法&#x2F;策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-负载均衡算法分类&quot;&gt;&lt;a href=&quot;#1-负载均衡算法分类&quot; class=&quot;headerlink&quot; title=&quot;1. 负载均衡算法分类&quot;&gt;&lt;/a&gt;1. 负载均衡算法分类&lt;/h1&gt;&lt;p&gt;抛开技术细节、根据算法的期望可以大致分为以下几类&lt;/p&gt;
&lt;table&gt;</summary>
      
    
    
    
    <category term="学习分享" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>《大型网站技术架构》| 读书笔记 | 【1】演化发展</title>
    <link href="http://example.com/posts/4a17b157.html"/>
    <id>http://example.com/posts/4a17b157.html</id>
    <published>2024-01-23T16:46:30.877Z</published>
    <updated>2024-01-25T09:46:30.460Z</updated>
    
    <content type="html"><![CDATA[<p>书名:   《大型网站技术架构：核心原理与案例分析》</p><h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><ul><li><p><strong>高并发、大流量</strong></p><ul><li>指标：PV、UV、IP、交易额、在线用户数</li></ul></li><li><p><strong>高可用</strong></p><ul><li>系统不间断服务</li></ul></li><li><p><strong>海量数据</strong></p><ul><li>存储、管理海量数据</li></ul></li><li><p><strong>用户分布广泛、网络情况复杂</strong></p><ul><li>系统为全球用户服务，因网络等原因，系统需全球化部署，即海外多地建立机器集群</li></ul></li><li><p><strong>需求快速变更、发布频繁</strong></p></li><li><p><strong>渐进式发展</strong></p></li></ul><p>​<strong>大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据，任何简单的业务一旦需要处理数以P计的数据和面向数以亿计的用户，问题就会变得很棘手。大型网站架构主要就是解决这类问题。</strong></p><h3 id="网站演化发展"><a href="#网站演化发展" class="headerlink" title="网站演化发展"></a>网站演化发展</h3><h4 id="阶段一-初始"><a href="#阶段一-初始" class="headerlink" title="阶段一  初始"></a>阶段一  初始</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240118195725752.png" alt="image-20240118195725752"></p><ul><li>应用程序、数据库、文件 通通都在一台服务器上</li></ul><h4 id="阶段二-应用服务和数据服务分离"><a href="#阶段二-应用服务和数据服务分离" class="headerlink" title="阶段二 应用服务和数据服务分离"></a>阶段二 应用服务和数据服务分离</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240118195708412.png" alt="image-20240118195708412"></p><ul><li><strong>问题：</strong> 用户多导致性能变差，数据多导致存储空间不足</li><li>应用数据和数据服务分离 &#x3D;&gt; 应用服务器、文件服务器、数据库服务器</li><li>三台服务器对硬件资源的要求各不相同<ul><li>应用服务器——应对大量的业务逻辑——更快更强的CPU</li><li>数据库服务器——快速的磁盘检索和数据缓存——更快的硬盘和更大的内存</li><li>文件服务器——存储大量用户的文件——更大的硬盘</li><li>应用和数据分离后，不同特性的服务器各司其职，提高了网站的并发能力和数据存储能力</li></ul></li></ul><h4 id="阶段三-使用缓存改善性能"><a href="#阶段三-使用缓存改善性能" class="headerlink" title="阶段三 使用缓存改善性能"></a>阶段三 使用缓存改善性能</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240118200309557.png" alt="image-20240118200309557"></p><ul><li><strong>问题：</strong>用户多，数据库压力太大，导致访问延迟，进而影响整个网站的性能，换句话说：<strong>数据库成为了系统瓶颈</strong></li><li>二八定律：80%的业务访问集中在20%的数据上</li><li>因此给这20%的数据缓存在内存中，理论上就可以减少数据库的访问压力，提高整个网站的数据访问速度。<ul><li>网站使用的缓存可以分为两种<ul><li>缓存在应用服务器上的本地缓存<ul><li>1、受应用服务器的内存限制</li><li>2、出现和应用程序争用内存的情况</li></ul></li><li>缓存在专门的分布式缓存服务器上的远程缓存——理论上可以做到不受内存容量限制<ul><li>1、集群的方式  （例如Redis的集群方式、Codis等）</li><li>2、大内存的服务器</li></ul></li></ul></li></ul></li></ul><h4 id="阶段四-使用应用服务器集群改善网站的并发处理能力"><a href="#阶段四-使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="阶段四 使用应用服务器集群改善网站的并发处理能力"></a>阶段四 使用应用服务器集群改善网站的并发处理能力</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119101020800.png" alt="image-20240119101020800"></p><ul><li><strong>问题</strong>：使用缓存后，数据访问压力得到有效缓解，但是单一应用服务区能够处理的请求连接有限，在网站高峰期，应用服务器成为整个网站的瓶颈。</li><li>通过负载均衡调度服务器，可将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多的用户，就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为整个网站的瓶颈。</li></ul><h4 id="阶段五-数据库读写分离"><a href="#阶段五-数据库读写分离" class="headerlink" title="阶段五 数据库读写分离"></a>阶段五 数据库读写分离</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119101646523.png" alt="image-20240119101646523"></p><ul><li>应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制，将数据更新同步到从数据库，这样当应用服务器读数据时，就可以通过从数据库获得数据。</li></ul><h4 id="阶段六-使用CDN和反向代理加速网站响应"><a href="#阶段六-使用CDN和反向代理加速网站响应" class="headerlink" title="阶段六 使用CDN和反向代理加速网站响应"></a>阶段六 使用CDN和反向代理加速网站响应</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119102905980.png" alt="image-20240119102905980"></p><ul><li><strong>问题</strong>：全球网络情况复杂，网站访问延迟，用户流失</li><li>CDN (内容分发网络) 的作用<ul><li>通过在多个地理位置建立一个入网点或一组CDN边缘服务器来工作<ul><li>缓存</li><li>动态加速(优化CDN服务器与应用服务器的连接)</li><li>边缘逻辑计算</li></ul></li></ul></li><li>反向代理的作用<ul><li>负载均衡，根据访问流量和服务器负载情况，将请求分发到不同的应用服务器</li><li>缓存</li><li>保护服务器，隐藏服务器真实 IP</li></ul></li><li>目的：都是为了尽早返回数据(缓存)给用户，同时也减轻了后端服务器的负载压力</li></ul><h4 id="阶段七-使用分布式文件系统和分布式数据库系统"><a href="#阶段七-使用分布式文件系统和分布式数据库系统" class="headerlink" title="阶段七 使用分布式文件系统和分布式数据库系统"></a>阶段七 使用分布式文件系统和分布式数据库系统</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119104722478.png" alt="image-20240119104722478"></p><ul><li><strong>问题：</strong>一台数据库&#x2F;文件服务器是满足不了持续增长的业务需求的。</li><li>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。</li><li>网站更常用的数据库拆分手段是业务分库，即将不同业务的数据库部署在不同的物理服务器上。</li></ul><h4 id="阶段八-使用NoSQL和搜索引擎"><a href="#阶段八-使用NoSQL和搜索引擎" class="headerlink" title="阶段八 使用NoSQL和搜索引擎"></a>阶段八 使用NoSQL和搜索引擎</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119105539838.png" alt="image-20240119105539838"></p><ul><li><strong>问题：</strong>网站的业务越来越复杂，对数据存储和检索的需求也越来越复杂</li><li>网站需要采用一些非关系型数据库技术(Redis、MongoDB)、非数据库查询技术如搜索引擎（ES）</li><li>应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦</li></ul><h4 id="阶段九-业务拆分-分布式服务"><a href="#阶段九-业务拆分-分布式服务" class="headerlink" title="阶段九 业务拆分-分布式服务"></a>阶段九 业务拆分-分布式服务</h4><p><img src="C:\Users\Administrator\Desktop\读书笔记\《大型网站技术架构：核心原理与案例分析》读书笔记.assets\image-20240119110456687.png" alt="image-20240119110456687"></p><ul><li>问题：日益复杂的业务场景</li><li>使用分而治之的手段将整个网站业务分成不同的产品线<ul><li>例如大型购物交易网站会将 首页、商铺、订单、买家、卖家等拆分为不同的产品线，分归不同的业务团队负责</li></ul></li><li>技术上，会根据不同的产品线，将网站拆分为多个应用，每个应用独立部署维护<ul><li>应用之间可以通过访问同一个数据存储系统构成一个关联的完整的系统。</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>大型网站的架构演化到这里，基本上大多数的技术问题都得以解决</p><ul><li>另外还有一些跨数据中心的实时数据同步问题  可以通过组合改进现有技术架构或引入新技术组件解决</li><li>如何把自己已经解决的问题的方案应用到别的业务上去 — 建设云计算平台，将计算作为一种基础资源出售，企业按需付费，另外存储、网络都可以按需购买。</li><li><strong>理解已成熟的网站架构技术方案的来龙去脉和历史渊源，在技术选型和架构决策才能有的放矢，直击要害。</strong></li></ul><h5 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h5><ul><li>没有哪个网站从诞生就是大型网站 (庞大用户、海量数据、高并发访问)，大型网站都是从小型网站发展而来的。</li><li>网站的价值在于它能为用户提供什么价值，而不是网站怎么做的，用了什么高级技术，否则就是舍本逐末。</li><li>驱动大型网站技术发展的主要力量是网站的业务发展，业务成就了技术，不要为了技术而技术。</li><li>当出现技术架构解决不了的问题时，可以看看是否是业务架构有问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书名:   《大型网站技术架构：核心原理与案例分析》&lt;/p&gt;
&lt;h3 id=&quot;大型网站软件系统的特点&quot;&gt;&lt;a href=&quot;#大型网站软件系统的特点&quot; class=&quot;headerlink&quot; title=&quot;大型网站软件系统的特点&quot;&gt;&lt;/a&gt;大型网站软件系统的特点&lt;/h3&gt;&lt;ul</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka | 1</title>
    <link href="http://example.com/posts/4a17b158.html"/>
    <id>http://example.com/posts/4a17b158.html</id>
    <published>2024-01-21T02:52:50.507Z</published>
    <updated>2024-01-23T16:59:24.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://img1.imgtp.com/2024/01/20/iJ5eYrGh.jpg">https://img1.imgtp.com/2024/01/20/iJ5eYrGh.jpg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="学习分享" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>BIGO</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2024-01-21T02:50:37.127Z</published>
    <updated>2024-01-21T02:54:09.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://img1.imgtp.com/2024/01/20/iJ5eYrGh.jpg">https://img1.imgtp.com/2024/01/20/iJ5eYrGh.jpg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="实习记录" scheme="http://example.com/categories/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
